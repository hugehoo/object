# Chapter02

클래스와 객체를 동일시 하지 말자. 클래스는 공통적인 상태와 행동을 공유하는 `객체를 추상화한 것`이다.
객체를 중심으로 사고화되 공동체의 협력하는 구성 요소로 생각하자.
- Domain : 문제를 해결하기 위해 사용자가 Program 을 사용하는 분야.

훌륭한 클래스를 설계하기 위한 핵심은 어떤 부분을 외부에 공개하고 어떤 부분을 감출지를 결정하는 것이다. <br>
클래스의 내부와 외부를 구분해야하는 이유는 무엇일까? 경계의 명확성이 객체의 자율성을 보장하기 때문이다.  <br>
-> 경계가 명확하지 않으면 외부에서 쉽게 객체의 data 에 접근할 수 있고 이는 캡슐화가 약해졌다는 의미이기도 하다. 자율적인 존재로 우뚝 서기 위해서는 외부의 간섭을 최소화해야 한다.

`객체`는 상태와 행동을 함께 정의한 것으로, 잘 정의된 객체는 연관성 높은 Data 와 기능을 내부에 함께 묶어 정의한다.

### 캡슐화
캡슐화의 접근제어는 객체를 두 부분으로 나눈다. <br> 
하나는 외부에서 접근 가능한 부분으로 이를 퍼블릭 인터페이스라고 부른다. <br>
다른 하나는 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 부분으로 이를 구현한다. 
일반적으로 객체의 상태는 숨기고 행동만 외부에 공개해야한다.

실행시 의존과 코드수준의 의존은 다를 수 있다. 확장 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것. 
설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다. 즉 객체지향적인 설계는 유연하고 확장가능하지만 쉽게 읽히지 않을 수 있다.

상속이 가치는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다. 여기서 모든 인터페이스란 모든 메시지로 볼 수 도 있는데 
이 메시지는 객체 간 상호작용할 때 사용되기 때문에, 부모 클래스를 물려받은 자식 클래스는 부모클래스 타입으로 다른 객체와 상호작용할 수 있다.
이는 곧 설명할 다형성과도 관계가 있다.

의존하는 객체는 자신과 협력하는 객체가 어떤 클래스의 인스턴스인지가 중요한 것이 아니라, 어떤 메시지를 수신할 수 있다는 사실이 중요하다. 
결국 어떤 객체인가보다, 어떤 메시지를 수신할 수 있느냐가 관건.

<br/>

### 다형성 : 메시지와 메서드

`메시지`와 `메서드`는 같아보이지만 다른 개념이다. 서로 다른 자식에서 구현된 메시지의 (구체적인) 내용이 같을리 없다.
메시지의 구현을 메서드라 생각하면 이 둘은 다른 개념일 수 밖에 없다. 서로 다른 할인 정책을 구현한 두 클래스의 메시지는 동일한 `메시지`(getDiscountAmount)를 가질 수 있지만,
각각의 할인 정책은 서로 다른 방벙으로 할인을 적용하기 때문에 둘의 내용(=`메서드`)은 달라질 수 있다.  
즉 동일한 메시지지만 서로 다른 형태를 가지며 이를 `다형성`이라 부른다.
`다형성`이란 동일한 메시지를 수신할 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다.
같은 메시지를 받는다는 건 동일한 인터페이스가 존재한다는 의미며, 동일한 메시지라도 객체 Type 에 따라 다른 내용을 응답할 수 있다.
이 때 서로 다른 클래스의 인터페이스를 통일하기 위해 사용한 구현 방법이 바로 상속이다,.

다형성은 객체지향 프로그램의 컴파일 시간 의존성과 런타임 의존성이 다를 수 있다는 사실을 기반으로 한다.
- Java 는 동적 바인딩과 정적 바인딩을 모두 지원. OOP 는 동적 바인딩 메커니즘 선택. 
- 클래스를 상속받는 것만이 다형성을 구현할 수 있는 유일한 방법은 아니다.

객체지향 패더라임의 중심에는 객체가 위치한다. <br> 
객체지향 설계의 핵심은 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 역할을 수행할 수 있는 적절한 객체에게 적절한 책임을 할당하는 것. 


